<?php
/***
 * Find Auxiliary Deletion in AutoGlosser data
 *
 * This script parses the data generated by the Bangor Autoglosser to detect any
 * utterances which feature auxiliary deletion and generates a report for import
 * into spreadsheet or statistical software from this.
 * The script parses the %aut dependent tier in CHAT files generated by the
 * Bangor AutoGlosser (http://www.siarad.org.uk/) for the first overt item, and
 * if this is a pronoun, subject to a few other checks assumes this is an
 * instance of AD. It compiles a list of all such instances which is then
 * written into a SQLite3 database and also exported as the tab-separated CSV
 * file "ad_list.csv". It also parses the original CHAT files for information
 * about the speakers, which is then written as the the CSV file
 * "speaker_data.csv" alongside the file index "file_list.csv". These files can
 * then be imported into spreadsheet or statistical software, whilst the
 * database "ad_data.sqlite" can be used for extraction of further information.
 * The script was developed to work with the Bangor Siarad corpus, but should
 * also work on other CHILDES corpora such as the Bangor Patagonia corpus.
 *
 * PHP Version 5.3
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License or the GNU
 * Affero General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * and the GNU Affero General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 *
 * @author     Florian Breit <florian.breit.12@ucl.ac.uk>
 * @copyright  2012 Florian Breit
 * @version    1.0.0
 * @package    BangorAutoglosser
 * @license    http://www.gnu.org/licenses/gpl.html
 * @license    http://www.gnu.org/licenses/agpl.html
 */

//
// Setup
//

//Some PHP stuff
error_reporting(E_ALL);
ini_set('display_errors', 1);
define('UTF8_BOM', chr(0xEF).chr(0xBB).chr(0xBF));

//Where to find the chat files for analysis
$original_dir = "./Siarad";
$autoglossed_dir = "./Siarad_autoglossed";
$out_dir = "./";

//
// MAIN SCRIPT FOR FINDING AD IN SIARAD
//

//Prepare database..
echo "Preparing database...\t\t";
$fh = @fopen($out_dir."/ad_data.sqlite", 'w'); //This will "empty" the db..
if( $fh === false ) {
    die("\nError: Could not open file `$out_dir/ad_data.sqlite' for writing.");
}
fclose($fh);
$db = new SQLite3($out_dir."/ad_data.sqlite", SQLITE3_OPEN_READWRITE);
$result = $db->exec("CREATE TABLE files
                        (
                            f_id        INTEGER PRIMARY KEY,
                            f_filename  TEXT
                        );                    
                    CREATE TABLE speakers
                        (
                            s_id        INTEGER PRIMARY KEY,
                            f_id        INTEGER,
                            s_name_code TEXT,
                            s_name      TEXT,
                            s_role      TEXT,
                            s_language  TEXT,
                            s_corpus    TEXT,
                            s_age       TEXT,
                            s_sex       TEXT,
                            s_group     TEXT,
                            s_SES       TEXT,
                            s_education TEXT
                        );
                    CREATE TABLE ad_instances
                        (
                            ad_id       INTEGER PRIMARY KEY,
                            s_id        INTEGER,
                            f_id        INTEGER,
                            ad_line_no  INTEGER,
                            ad_person   INTEGER,
                            ad_number   TEXT,
                            ad_persnum  TEXT,
                            ad_extract  TEXT
                        );");
if(!$result) {
    die('SQL Error at line '.__LINE__.': '.$db->lastErrorMsg());
}
echo "Done\n";

//Extract all file names to search for ad...
echo "Creating file index...\t\t";
$filelist = array();
$dir = @dir($autoglossed_dir) or die("\nThe directory with the autoglossing "
                                     ."data could not be found.");
$stmt = $db->prepare('INSERT INTO files
                        (f_filename)
                        VALUES
                        (:f_filename);');
while(false !== $file = $dir->read()) {
    if(substr($file, -4) == ".cha") { //Only chat files
        $stmt->reset();
        $stmt->bindValue(':f_filename', $file);
        $stmt->execute();
        $f_id = $db->lastInsertRowID();
        $filelist[] = array($file, $f_id);
    }
}
echo "Done.\n";

//Write file list...
echo "Writing file list...\t\t";
$fh = @fopen($out_dir."/file_list.csv", 'w');
if( $fh === false ) {
    die("\nError: Could not open file `$out_dir/file_list.csv' for writing.");
}
fwrite($fh, UTF8_BOM);
fwrite($fh, "f_id\tf_filename\n");
foreach($filelist as $file) {
    fwrite($fh, implode("\t", $file)."\n");
}
fclose($fh);
echo "Done.\n";

//Extract speaker data..
echo "Extracting speaker data...\t";
$last_count = 0;
$speaker_index = array();
$stmt = $db->prepare('INSERT INTO speakers
                        (
                            f_id,
                            s_name_code,
                            s_name,
                            s_role,
                            s_language,
                            s_corpus,
                            s_age,
                            s_sex,
                            s_group,
                            s_SES,
                            s_education
                        )
                        VALUES
                        (
                            :f_id,
                            :s_name_code,
                            :s_name,
                            :s_role,
                            :s_language,
                            :s_corpus,
                            :s_age,
                            :s_sex,
                            :s_group,
                            :s_SES,
                            :s_education
                        );');
for($i=0; $i<count($filelist); $i++) {
    list($filename, $f_id) = $filelist[$i];
    shell_del_chrs($last_count);
    $out_str = '('.($i+1).'/'.count($filelist).')';
    echo $out_str;
    $last_count = strlen($out_str);
    $speakers = extract_speaker_data($original_dir."/".$filename);
    foreach($speakers as $speaker) {
        $stmt->reset();
        $stmt->bindValue(':f_id',           $f_id);
        $stmt->bindValue(':s_name_code',    $speaker['name_code']);
        $stmt->bindValue(':s_name',         $speaker['name']);
        $stmt->bindValue(':s_role',         $speaker['role']);
        $stmt->bindValue(':s_language',     $speaker['language']);
        $stmt->bindValue(':s_corpus',       $speaker['corpus']);
        $stmt->bindValue(':s_age',          $speaker['age']);
        $stmt->bindValue(':s_sex',          $speaker['sex']);
        $stmt->bindValue(':s_group',        $speaker['group']);
        $stmt->bindValue(':s_SES',          $speaker['SES']);
        $stmt->bindValue(':s_education',    $speaker['education']);
        $stmt->execute();
        $s_id = $db->lastInsertRowID();
        $speaker_index[] = array_merge(array('s_id' => $s_id,
                                             'f_id' => $f_id),
                                       $speaker);
    }
}
shell_del_chrs($last_count);
unset($last_count);
echo "Done.\n";

//Write speaker data...
echo "Writing speaker data...\t\t";
$fh = @fopen($out_dir."/speaker_data.csv", 'w');
if( $fh === false ) {
    die("\nError: Could not open file `$out_dir/speaker_data.csv'"
        ."for writing.");
}
fwrite($fh, UTF8_BOM);
fwrite($fh, "s_id\tf_id\ts_name_code\ts_name\ts_role\ts_language\ts_corpus\t"
            ."s_age\ts_sex\ts_group\ts_SES\ts_education\n");
foreach($speaker_index as $speaker) {
    fwrite($fh, implode("\t", $speaker)."\n");
}
fclose($fh);
echo "Done.\n";

//Find ad lines for every file...
echo "Parsing files for ad lines...\t";
$last_count = 0;
$ad_index = array();
$stmt1 = $db->prepare('SELECT s_id, s_name_code
                        FROM speakers
                        WHERE f_id = :f_id;');
$stmt2 = $db->prepare('INSERT INTO ad_instances
                        (
                            s_id,
                            f_id,
                            ad_line_no,
                            ad_person,
                            ad_number,
                            ad_persnum,
                            ad_extract
                        )
                        VALUES
                        (
                            :s_id,
                            :f_id,
                            :ad_line_no,
                            :ad_person,
                            :ad_number,
                            :ad_persnum,
                            :ad_extract
                        );');
for($i=0; $i<count($filelist); $i++) {
    list($filename, $f_id) = $filelist[$i];
    shell_del_chrs($last_count);
    $out_str = '('.($i+1).'/'.count($filelist).')';
    echo $out_str;
    $last_count = strlen($out_str);
    $stmt1->reset();
    $stmt1->bindValue('f_id', $f_id);
    $results = $stmt1->execute();
    $speakers = array();
    while($result = $results->fetchArray()) {
        $speakers[$result['s_name_code']] = $result['s_id'];
    }
    $ad_lines = find_ad($autoglossed_dir."/".$filename);
    foreach($ad_lines as $ad_line) {
        $stmt2->reset();
        $stmt2->bindValue(':s_id',       $speakers[$ad_line['name_code']]);
        $stmt2->bindValue(':f_id',       $f_id);
        $stmt2->bindValue(':ad_line_no', $ad_line['line_no']);
        $stmt2->bindValue(':ad_person',  (int) $ad_line['g_person']);
        $stmt2->bindValue(':ad_number',  $ad_line['g_number']);
        $stmt2->bindValue(':ad_persnum', $ad_line['g_persnum']);
        $stmt2->bindValue(':ad_extract', $ad_line['extract']);
        $stmt2->execute();
        $ad_id = $db->lastInsertRowID();
        $ad_index[] = array('ad_id'         => $ad_id,
                            's_id'          => $s_id,
                            'f_id'          => $f_id,
                            'ad_line_no'    => $ad_line['line_no'],
                            'ad_person'     => $ad_line['g_person'],
                            'ad_number'     => $ad_line['g_number'],
                            'ad_persnum'    => $ad_line['g_persnum'],
                            'ad_extract'    => $ad_line['extract']
                            );
    }
}
shell_del_chrs($last_count);
unset($last_count);
echo "Done.\n";

//Write ad instances...
echo "Writing list of AD instances...\t";
$fh = @fopen($out_dir."/ad_list.csv", 'w');
if( $fh === false ) {
    die("\nError: Could not open file `$out_dir/ad_list.csv' for writing.");
}
fwrite($fh, UTF8_BOM);
fwrite($fh, "ad_id\ts_id\tf_id\tad_line_no\tad_person\tad_number\tad_persnum\t"
            ."ad_extract\n");
foreach($ad_index as $ad_line) {
    fwrite($fh, implode("\t", $ad_line)."\n");
}
fclose($fh);
echo "Done.\n";

echo "Script execution is complete.\n";

//
// CLASSES AND FUNCTIONS
//

/***
 * Delete Characters from Shell STDOUT
 *
 * This function overwrites the last n characters on STDOUT with whitespace and
 * then sets the cursor to the beginning of that whitespace. This only works in
 * a shell environment when backspaces can override the current line and does
 * not work across linebreaks.
 *
 * @param int $count How many characters to overwrite
 * @return void
 */
function shell_del_chrs($count) {
    for($i=0;$i<$count;$i++) {
        echo chr(8); //return to left
    }
    for($i=0;$i<$count;$i++) {
        echo ' '; //overwrite with ws
    }
    for($i=0;$i<$count;$i++) {
        echo chr(8); //return to left
    }
}

/***
 * Extract speaker data from CHAT files
 *
 * This function extracts all available data about participants from the given
 * CHAT file.
 *
 * @param string $filename The CHAT file from which the data should be extracted
 * @return array Returns a numeric array of the speaker information
 */
function extract_speaker_data($filename) {
    //Open and parse file
    $cf = new ChatDocument($filename);
    $cf->parseFile();
    
    //Get all header lines
    $speaker_data = array();
    $header_lines = $cf->getHeaderLines();
    foreach($header_lines as $header_line) {
        switch(strtolower($header_line->getIdentifier())) {
            case 'participants':
                //data will be of the format XXX Name Role, XXX Name Role, ...
                $parts_header = $header_line->getData();
                $parts_header = explode(',', $parts_header);
                foreach($parts_header as $parts_item) {
                    $parts_item = explode(' ', trim($parts_item), 3);
                    $id = $parts_item[0];
                    if(count($parts_item) < 3) {
                        //no name is given (names are optional)
                        $name = '';
                        $role = $parts_item[1];
                    } else {
                        $name = $parts_item[1];
                        $role = $parts_item[2];
                    }
                    $filename = $header_line->getParent()->getFilename();
                    $filename = basename($filename);
                    $speaker_data[$id] = array('name_code' => $id,
                                               'name' => $name,
                                               'role' => $role
                                               );
                }
                break;
            case 'id':
                //Format is: lang|corpus|code|age|sex|group|SES|role|edu|
                //Index:       0    1     2    3   4   5     6   7    8
                $id_header = $header_line->getData();
                $id_header = explode('|', $id_header);
                $speaker_data[$id_header[2]] += array('language'  => $id_header[0],
                                                      'corpus'    => $id_header[1],
                                                      'age'       => $id_header[3],
                                                      'sex'       => $id_header[4],
                                                      'group'     => $id_header[5],
                                                      'SES'       => $id_header[6],
                                                      'education' => $id_header[8]
                                                      );
                break;
        }
    }
    
    //replace array keys with numbered index
    $new_speaker_data = array();
    foreach($speaker_data as $item) {
        $new_speaker_data[] = $item;
    }
    
    return $new_speaker_data;
}

/***
 * Find instances of Auxiliary Deletion in an AutoGlosser CHAT file
 *
 * This function searches the given CHAT file's dependent tier %aut line
 * generated by the Bangor AutoGlosser for instances where the first over item
 * is a personal pronoun and returns an array
 *
 * @param string $filename The CHAT file which should be parsed for AD instances
 * @return array Returns an array of AD instances in the specified CHAT file
 */
function find_ad($filename) {
    //Open and parse file
    $cf = new ChatDocument($filename);
    $cf->parseFile();
    
    //Get all autoglosser lines
    $aut_lines = array();
    $part_lines = $cf->getPartLines();
    foreach($part_lines as $part_line) {
        $dependent_lines = $part_line->getDependentLines();
        foreach($dependent_lines as $dependent_line) {
            if($dependent_line->getIdentifier() == 'aut') {
                $aut_lines[] = $dependent_line;
            }
        }
    }
    unset($part_line, $part_lines, $dependent_line, $dependent_lines);
    
    //Find lines that begin with pronouns
    $ad_lines = array();
    foreach($aut_lines as $aut_line) {
        $first_item = trim($aut_line->getData()); //rm any empty glosses
        $first_item = substr($first_item, 0, strpos($first_item, ' ')); //1st ws
        if(!empty($first_item)) {
            $first_item = explode('.', $first_item);
            if( count($first_item) == 3         //match for xxx.xxx.xxx
                && $first_item[1] == 'PRON'     //match for xxx.PRON.xxx
                && is_numeric($first_item[2][0])//march for xxx.xxx.(0-9)xx
                ) {
                //This is probably an AD clause! It starts with a pronoun..
                //Now gather data about it...
                $filename = $aut_line->getParent()->getParent()->getFilename();
                $filename = basename($filename);
                $line_no = $aut_line->getOrigLineNo();
                $speaker = $aut_line->getParent()->getIdentifier();
                $g_person = $first_item[2][0];
                $g_number = $first_item[2][1];
                $extract = substr($aut_line->getParent()->getData(), 0, 50);
                $ad_lines[] = array('name_code' => $speaker,
                                    'g_person' => $g_person,
                                    'g_number' => $g_number,
                                    'g_persnum' => $g_person.$g_number,
                                    'line_no' => $line_no,
                                    'extract' => $extract
                                    );
            }
        }
    }
    
    return $ad_lines;
}

/***
 * Root Class for CHAT Objects
 *
 * This is a generic root class from which all other CHAT Objects are derived.
 * It cannot be directly instanciated.
 *
 * @package ChatTools
 * @abstract
 */
abstract class ChatObject {
    
    //dummy class    
}

/***
 * CHAT Document Class
 *
 * This class provides functionality for reading, parsing, modifying and writing
 * CHAT files as used by in the CHILDES project.
 * If parses the lines in the CHAT file and builds a structure from these so
 * that every line has a parent showing its relations to other lines in the CHAT
 * document. Headers and Participant lines are children of the ChatDocument,
 * while the dependent tier lines are children of their headin Participant line.
 *
 * @package ChatTools
 * @link http://childes.psy.cmu.edu/manuals/chat.pdf The manual for CHAT files
 */
class ChatDocument extends ChatObject {

    /***
     * Filename of the CHAT file the ChatDocument operates on
     *
     * This should be set and retrieved using the setFilename() and
     * getFilename() methods, which ensure that the file exists and is
     * writeable.
     *
     * @access protected
     */
    protected $filename;
    /***
     * Array of the header lines in the CHAT document
     *
     * This is an array of all the header lines in the CHAT document. It may be
     * retrieved or modified using the setHeaderLines() and getHeaderLines()
     * methods.
     *
     * @access protected
     */
    protected $header_lines;
    /***
     * Array of the participant lines in the CHAT document
     *
     * This is an array of all the participant lines in the CHAT document. These
     * have the dependend tier lines as children. It may be retrieved or
     * modified using the setPartLines() and getPartLines() methods.
     *
     * @access protected
     */
    protected $part_lines;
    
    /***
     * Class Constructor
     *
     * This is the class constructor. It takes one argument, which is the
     * filename of the CHAT file that shall be manipulated. If you want to
     * create a new CHAT file, you must first create an empty file which you
     * can then manipulate with the class. The file must exist and be writeable.
     * Note that the class does not automatically parse the file upon creation,
     * so if it is not a new file you must still call the parseFile() method to
     * parse it.
     *
     * @param string $filename Filename of the CHAT file to be loaded
     * @access public
     * @return void
     */
    public function __construct($filename) {
        $this->setFilename($filename);
    }
    
    /***
     * Set filename of CHAT document
     *
     * This sets the filename of the CHAT document. It is automaticlly called
     * when the object is created and may later be used to modify the filename,
     * e.g. when you want to save the file under a different name after having
     * manipulated it. The given file must both exist and be writeable, if it
     * is intended to be a new file, you must first create it.
     *
     * @param string $filename The new filename to use for the document
     * @access public
     * @return void
     */
    public function setFilename($filename) {
       $this->checkFile($filename);
       $this->filename = $filename;
    }
    
    /***
     * Get filename of CHAT document
     *
     * This returns the filename currently used by the ChatDocument.
     *
     * @return string Returns the filename of the document
     * @access public
     */
    public function getFilename() {
        return $this->filename;
    }
    
    /***
     * Set CHAT Header Lines for the CHAT document
     *
     * This function lets you replace the complete set of header lines used by
     * the CHAT document. It must be given as an indexed array, each item of
     * which is a valid ChatHeaderLine object whith this instance of the
     * ChatDocument as its parent.
     *
     * @param $lines The array of ChatHeaderLine objects to be used
     * @access public
     * @return void
     */
    public function setHeaderLines(array $lines) {
        foreach($lines as $line) {
            if( !is_a($line, 'ChatHeaderLine') ) {
                throw new InvalidArgumentException("The given array of ChatLine"
                                                   ." headers contains members "
                                                   ."that are not valid "
                                                   ."ChatHeaderLine objects.");
            }
        }
        $this->header_lines = $lines;
    }
    
    /***
     * Get CHAT Header Lines for the CHAT document
     *
     * This returns a numeric array of all the header lines of the CHAT document
     *
     * @return array An array of all the headers in the document
     * @access public
     */
    public function getHeaderLines() {
        return $this->header_lines;
    }
    
    /***
     * Set CHAT Participant Lines for the CHAT document
     *
     * This function lets you replace the complete set of participant lines used
     * by the CHAT document. It must be given as an indexed array, each item of
     * which is a valid ChatPartLine object whith this instance of the
     * ChatDocument as its parent.
     *
     * @param $lines The array of ChatPartLine objects to be used
     * @access public
     * @return void
     */
    public function setPartLines(array $lines) {
        foreach($lines as $line) {
            if( !is_a($line, 'ChatPartLine') ) {
                throw new InvalidArgumentException("The given array of "
                                                   ."participant ChatLines "
                                                   ."contains members that are "
                                                   ."not valid ChatPartLine "
                                                   ."objects.");
            }
        }
        $this->part_lines = $lines;
    }
    
    /***
     * Get CHAT Participant Lines for the CHAT document
     *
     * This returns a numeric array of all the participant lines of the CHAT
     * document
     *
     * @return array An array of all the participant lines in the document
     * @access public
     */
    public function getPartLines() {
        return $this->part_lines;
    }
    
    /***
     * Check whether the specified file exists and is writeable
     *
     * This method checks whether the file specified by $filename exists and is
     * writeable. The $filename argument is optional and if not given the
     * current filename of the ChatDocument will be used instead.
     *
     * @param string $filename The path to the file to check
     * @return bool Returns true if the filename is valid, otherwise throws
     *              an InvalidArgumentException.
     * @access protected
     */
    protected function checkFile($filename=null) {
        if( $filename == null ) {
            $filename = $this->filename;
        }
        if( !file_exists($filename) ) {
            throw new InvalidArgumentException("The specified file `$filename' "
                                               ."does not exist.");
        }
        if( !is_writable($filename) ) {
            throw new InvalidArgumentException("The specified file `$filename' "
                                               ."is not writeable.");
        }
        return true;
    }
    
    /***
     * Parse the associated CHAT file
     *
     * This method will parse the associated CHAT file (see $filename) and
     * overwrite any current header and participant lines with those from the
     * file. Note that the dependent tier lines are accessible through their
     * parent ChatPartLine objects.
     *
     * @return void
     * @access public
     */
    public function parseFile() {
        $this->checkFile();
        $lines = file($this->filename);
        $last_part_line = false;
        for($i=0; $i<count($lines); $i++) {
            $lines[$i] = rtrim($lines[$i], "\r\n");
            switch($lines[$i][0]) {
                case '@':
                    $x = new ChatHeaderLine($this, $lines[$i]);
                    $x->setOrigLineNo($i+1);
                    $this->header_lines[] = $x;
                    break;
                case '*':
                    $last_part_line = new ChatPartLine($this, $lines[$i]);
                    $last_part_line->setOrigLineNo($i+1);
                    $this->part_lines[] = $last_part_line;
                    break;
                case '%':
                    $x = new ChatDependentLine($last_part_line,
                                               $lines[$i],
                                               $last_part_line);
                    $x->setOrigLineNo($i+1);
                    break;
            }
        }
        unset($x, $last_part_line);
    }
}

/***
 * Base class for CHAT lines
 *
 * This is an abstract class that provides some base functionality for all types
 * if CHAT lines: header lines, participant lines, and dependent tier lines.
 * These three different types of lines have their own respective classes
 * derived from this class: ChatHeaderLine, ChatPartLine and ChatDependentLine.
 * ChatLine cannot be used directly, but you can use it to check whether a given
 * object is any type of CHAT line with the is_a() function.
 *
 * @abstract
 */
abstract class ChatLine extends ChatObject {
    
    /***
     * Reference to Parent ChatObject
     *
     * This is a reference to the line's parent ChatObject. This may be another
     * ChatLine or a ChatDocument. The parent can only be set on construction
     * and thereafter not be modified. You can use the method getParent() to
     * obtain a reference to the parent item of a ChatLine.
     *
     * @access protected
     */
    protected $parent;
    /***
     * Identifier of the CHAT line
     *
     * Every CHAT line has an identifier, usually inbetween one of @, * or % and
     * a colon :, these are three letters long for participant lines and
     * dependent tier lines and can be of varying length for header lines. A
     * special case are the Begin and End identifiers, which are not followed by
     * a colon in the CHAT file. Note that the identifier maintained here does
     * not have any of the @, *, % and : characters, since they are predictable
     * from the other properties of the object. So for "*EXA:" this would
     * contain the string "EXA", for "@Comment:" it would be "Comment", etc.
     * This can be modified using the setIdentifier() and getIdentifier()
     * methods.
     *
     * @access protected
     */
    protected $identifier;
    /***
     * Line data of the CHAT line
     *
     * This contains the actual data of the given CHAT line, i.e. what normally
     * follows the identifier and a tab character. This would be things such as
     * the actual transcription or the gloss text, depending on the type of CHAT
     * line.
     * You should use the setData() and getData() methods to modify this.
     *
     * @access protected
     */
    protected $data;
    /***
     * Original Line Number
     *
     * If the line was parsed from an existing CHAT file, then this contains the
     * line number at which the line was originally positioned in the file when
     * parsed. This can be useful for finding it in the raw file data if needed.
     * If the ChatLine was not originally parsed from a file this is 0.
     * Otherwise it will be any number of 1 or above.
     * You may optionally use the setOrigLineNo() and getOrigLineNo() methods to
     * modify this value.
     *
     * @access public
     */
    public $orig_line_no = 0;
    
    /***
     * Constructor for ChatLine objects
     *
     * This is a generic constructor function for ChatLine objects. It takes the
     * parent document and the raw line data (not the line data contained in the
     * ChatLine object) as its arument.
     *
     * @param ChatDocument $parent The parent ChatDocument for the line
     * @param string $data The raw, unparsed, line from the CHAT file
     * @access public
     * @return void
     */
    public function __construct(ChatDocument $parent, $data) {
        $this->parent = $parent;
        $this->parseLine($data);
    }
    
    /***
     * Set the Original Line Number
     *
     * This sets the original line number of the ChatLine object. This should be
     * a reference to where the line was originally positioned in the CHAT file
     * before parsing.
     *
     * @param int $line_no The line number of the line in the CHAT file
     * @return void
     * @access public
     */
    public function setOrigLineNo($line_no) {
        $this->orig_line_no = (int) $line_no;
    }
    
    /***
     * Get the Original Line Number
     *
     * This returns the original line number of the ChatLine object. This is a
     * reference to where the line was originally positioned in the CHAT file
     * before parsing. This may be useful for looking up the raw data in the
     * CHAT file.
     *
     * @return int Returns the original line number
     * @access public
     */
    public function getOrigLineNo() {
        return (int) $this->orig_line_no;
    }
    
    /***
     * Parse a line from raw data
     *
     * This method parses the given data into the identifier and the line data
     * and stores these in the present ChatLine object.
     *
     * @param $data The unparsed, raw data from the CHAT file
     * @return void
     * @access protected
     */
    protected function parseLine($data) {
        //Identifier: *XXX: -> XXX; %xxx: -> xxx; @x...x:, -> x...x
        $this->identifier = substr($data, 1, strpos($data, ':')-1);
        //Remaining data on line
        $tier = substr($data, strpos($data, "\t")+1);
        $this->data = $tier; //Eventually one could break down the individual
                             //items on the tier...
    }
    
    /***
     * Get Parent ChatObject
     *
     * This returns a reference to the parent ChatObject of the present ChatLine.
     *
     * @return ChatObject Returns the parent ChatObject
     * @access public
     */
    public function getParent() {
        return $this->parent;
    }
    
    /***
     * Get Identifier
     *
     * This returns the identifier of the ChatLine object. See the description
     * of the $identifier variable for more information on what this is.
     *
     * @return string Returns the identifier of the CHAT line
     * @access public
     */
    public function getIdentifier() {
        return $this->identifier;
    }
    
    /***
     * Get Line Data
     *
     * This method returns the line data for the present ChatLine. This is
     * usually what comes behind the line identifier (e.g. "xyz in "*EXA: xyz").
     * See the description of the $data variable for further information.
     *
     * @return Returns the line data for the CHAT line
     * @access public
     */
    public function getData() {
        return $this->data;
    }
}

/***
 * CHAT Header Line Class
 *
 * This class implements representations of header lines (lines beginning with @
 * in the CHAT file format). At present, it's functionality is identical to that
 * of ChatLine and so its main use if for type hinting purposes.
 */
class ChatHeaderLine extends ChatLine {
    
    //this does not provide any extra functionality to other ChatLines
}

/***
 * CHAT Participant Line Class
 *
 * This class implements representations of participant lines (lines that begin
 * with an asterisk * in CHAT files). It extends the ChatLine object for some
 * functionality relating to its ability to have subordained dependent tier
 * lines.
 */
class ChatPartLine extends ChatLine {
    
    /***
     * The Line's Dependent Tier
     *
     * This contains an array of all the dependent tier lines which are
     * dependent on the participant line.
     *
     * @access protected
     */
    protected $dependent_lines = array();
    
    /***
     * Add a dependent line
     *
     * This adds a dependent tier line to the participant line. If the lines is
     * already dependent on the participant line it the method call will be
     * ignored as references are unique.
     *
     * @param ChatDependentLine $line The dependent tier line to be added
     * @return void
     * @access public
     */
    public function addDependentLine(ChatDependentLine $line) {
        if( !in_array($line, $this->dependent_lines) ) {
            $this->dependent_lines[] = $line;
        }
    }
    
    /***
     * Set all dependent lines
     *
     * This method is similar to addDependentLine() but it allows for the whole
     * array of dependent tier lines to be replaced at once.
     *
     * @param array $lines An array of ChatDependentLine objects
     * @return void
     * @access public
     */
    public function setDependentLines(array $lines) {
        foreach($lines as $line) {
            if(!is_a($line, 'ChatDependentLine')) {
                throw new InfiniteIterator("The given array of dependent "
                                           ."ChatLines contains members that "
                                           ."are not valid ChatDependentLine "
                                           ."objects.");
            }
        }
        $this->dependent_lines = $lines;
    }
    
    /***
     * Get dependent lines
     *
     * This returns an array of all the dependent tier lines associated with
     * this CHAT line.
     *
     * @return array An array of ChatDependentLine objects
     * @access public
     */
    public function getDependentLines() {
        return $this->dependent_lines;
    }
}

/***
 * CHAT Dependent Tier Line Class
 *
 * This class extends the ChatLine class for some changed functionality.
 * Specifically since dependent tier lines are dependent on participant lines
 * and not ChatDocuments, it changes this so the parent document must be a
 * CharPartLine, not a ChatDocument.
 */
class ChatDependentLine extends ChatLine {
    
    /***
     * ChatDependentLine constructor
     *
     * This is the constructor for dependent tier lines. It behaves like the
     * constructor for ChatLine but instead of a ChatDocument for the $parent
     * parameter it expects a CharPartLine.
     *
     * @param ChatPartLine $parent The parent ChatPartLine for the line
     * @param string $data The raw, unparsed, line from the CHAT file
     * @access public
     * @return void
     */
    public function __construct(ChatPartLine $parent, $data) {
        $this->parent = $parent;
        $this->parent->addDependentLine($this);
        $this->parseLine($data);
    }
}
?>
